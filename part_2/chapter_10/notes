The implicit conversions that preserve values are called "promotions." Integers are promoted automatically during arithmetic operations, short ints will become ints. These promotions are designed to normalize the size of variables for arithmetic operations. Therefore, promotion to long or long long does not occur. As always, there are exceptions to the rules, and exceptions to the exceptions to the rule. This seems to be a pattern in C++. Anyway, the types char16_t, char32_t, wchar_t, and plain enums that are already larger than int  will be promoted to long if necessary. The following promotion table describes the promotions in the order they would occur. For example "-> int, unsigned int" means that first promotion to int will be attempted if possible, otherwise promotion to unsigned int will occur.

char, signed char, unsigned char, short int, unsigned short int -> int, unsigned int.
char16_t, char32_t, wchar_t, plain enum -> int, unsigned int, long, unsigned long, unsigned long long.
bit-field -> int, unsigned int, not promoted if all bit values dont fit into sizeof(int).
bool -> int


"The fundamental types can be implicitly converted into each other in a bewildering number of ways. In my opinion, too many conversions are allowed." Some of the most dangerous conversions are called "narrowing conversions." These conversions truncate types, resulting in loss of data or precision. C++ offers protection against narrowing conversions via narrow_cast<>(), a runtime checked conversion function. Another way to guard against narrowing is to utilize the {} initializer syntax. Using brackets prevents narrowing and will throw a compiler error, like "double precision floating point to char conversion." Conversions are complex and the behavior should be evaluated on a case by case basis, since there are so many possibilities. When writing production code, always be wary of conversions and use a debugger to ensure that your data isn't being silently clobbered. Here is a real-world example of an integer narrowing bug in Firefox that results in out-of-bounds array access (essentially allows an attacker to possibly leak process memory): https://bugzilla.mozilla.org/show_bug.cgi?id=1383951

"Inside the JavaScript parser, a cast of an integer to a narrower type can result in data read from outside the buffer being parsed. This usually results in a non-exploitable crash, but can leak a limited amount of information from memory if it matches JavaScript identifier syntax. This vulnerability affects Firefox < 56."

Pointer, integral, and floating-point values can be implicitly converted to bool. A nonzero value converts to true; a zero value converts to false. This can allow for some dubious development practices, like the following code. Note that Bjarne is against this "hack" and states "Hope for a compiler warning for func2(p)."

When a floating point value is converted to int, the fractional part is discarded. Some closing remarks from Bjarne: avoid complicated expressions; if in doubt about operator precedence, use parenthesis; avoid narrowing conversions; define symbolic constants to avoid "magic constants." By the last point, he means use something like "const int ARRAY_SIZE = 1024" instead of using the number 1024 during array allocation. This development practice can and will make the code more maintainable and less prone to memory corruption.
