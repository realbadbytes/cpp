This chapter deals with the basic language mechanisms for referring to memory. A '*' denotes a pointer to an object in memory. A pointer holds the address of an object. At its lowest level, object members are accessed via offsets from this pointer. In assembly language, you'll often see things like [rax+0x8], meaning "dereference the pointer in rax, and go to offset 0x8" which could be the 'name' field in a user defined object, for example. There are many possibilities with the '*' aka 'pointer to' unary operator. Getting a bit more complicated than the above example, you can have pointers to pointers, arrays of pointers, pointers to functions, and more. You can utilize https://cdecl.org/ to demangle this syntax as things get confusing. For example inputting "int (*fp)(char*);" results in "declare fp as pointer to function (pointer to char) returning int." In the code below, you'll see two arrays of int pointers. Notice how one is not initialized properly, causing random stack data possibly from previous function calls to be included in the array. If one of those "uninitialized" values is dereferenced, good luck.

A void pointer is used to pass or store an address of a memory location without knowing what is stored there. Said by Stroustrup, "pointer to an object of an unknown type." Void pointer is primarily used for passing pointers to functions that are not allowed to make assumptions about the type of the object and for returning untyped objects from functions. To use such an object, we must use explicity type conversion. Using void* should be highly scrutinized in code review, they are most likely an indication of bad design decisions. 

nullptr is a literal that represents the null pointer. It is part of the standard namespace, as std::nullptr_t. The predecessor to nullptr was simply to use zero. Avoid the use of NULL as its definition can be implementation-defined.


 
